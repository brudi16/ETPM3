$version 11.00

// This is the root component of the entire GUI application.
$rect <70,-230,270,-190>
$output false
class Application : Core::Root
{
  $rect <30,340,210,380>
  inherited method Init()
  {
    var Core::Group newDialog = new Application::WelcomeScreen;
    PresentDialog( newDialog, null, null, null, null, null, null, null, null, false );
  }

  $rect <270,10,470,50>
  inherited property Bounds = <0,0,240,320>;

  // To do:
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widgets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <470,410,1250,610>;
  }
}

// This is a font resource.
$rect <550,-200,750,-160>
$output false
resource Resources::Font Font
{
  attr fontname FontName = Arial;
  attr fontheight Height = 32;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

$rect <550,-240,750,-200>
$output false
resource Resources::Font TitelFont
{
  attr fontname FontName = Roboto Medium;
  attr fontheight Height = 32;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <290,-230,490,-190>
$output false
class WelcomeScreen : Core::Group
{
  $rect <250,0,450,40>
  inherited property Bounds = <0,0,240,320>;

  $rect <250,90,450,130>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <250,50,450,90>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <460,280,1240,600>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <29,69,211,252>;
    preset AutoSize = false;
    preset Endless = true;
    preset Bitmap = Application::ZhawLogo;
    preset Embedded = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <240,0>;
    preset Point2 = <240,320>;
    preset Point1 = <0,320>;
    preset OnRelease = UpdateViewMenu;
  }

  $rect <250,160,450,200>
  slot UpdateViewMenu
  {
    var Core::Group newDialog = new Application::Menu;
    if (IsCurrentDialog())
      SwitchToDialog( newDialog, null, null, null, null, null, null, null, null, null, false );
  }
}

// Views
note group Views
{
  attr Bounds = <50,-280,510,420>;
}

// Resources
note group Resources
{
  attr Bounds = <530,-280,770,260>;
}

$rect <290,-190,490,-150>
$output false
class DetectorScreen : Core::Group
{
  $rect <260,0,460,40>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,100,460,140>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,60,460,100>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <480,290,1260,610>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <56,62,184,211>;
    preset Animated = false;
    preset Bitmap = Application::WarnSign;
  }

  $rect <20,20,160,60>
  object Views::Text WarningMessage
  {
    preset Bounds = <0,168,240,254>;
    preset String = "MAINS CABLE\nDETECTED!";
    preset Font = Application::Font;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <0,0,240,86>;
    preset String = "Detector";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset Icon = Application::HomeIcon;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,160,460,200>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <550,60,750,100>
  object Effects::BoolEffect ShowIcon
  {
    preset Outlet = ^Image.Visible;
    preset Enabled = true;
  }

  $rect <550,100,750,140>
  object Effects::BoolEffect ShowText
  {
    preset Outlet = ^WarningMessage.Visible;
    preset Enabled = false;
  }

  $rect <550,160,750,200>
  method void Method()
  {
    //if(false){
    //  ShowIcon.Enabled = true;
    //  ShowText.Enabled = true;
    //} else {
      Image.Visible = false;
    //}

  }
}

$rect <290,-150,490,-110>
$output false
class CurrentMeasurement : Core::Group
{
  $rect <250,0,450,40>
  inherited property Bounds = <0,0,240,320>;

  $rect <250,160,450,200>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <250,120,450,160>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,80>;
    preset String = "Current\nMeasurement";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::Gauge Gauge
  {
    preset Bounds = <0,80,240,261>;
    preset Enabled = true;
    preset Outlet = ^Application::Device.Current;
    preset MaxValue = 10;
    preset CurrentValue = 5;
    preset Appearance = Application::BlueGauge;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[];
    preset Bounds = <83,160,157,192>;
    preset Outlet = ^Application::Device.Current;
    preset Unit = "A";
    preset Precision = 1;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset Icon = Application::HomeIcon;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <250,220,450,260>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }
}

$rect <290,-70,490,-30>
$output false
class Utilities : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,51>;
    preset String = "Utilities";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <260,200,460,240>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset Icon = Application::HomeIcon;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,135,195,185>;
    preset OnRelease = UpdateViewCalibration;
    preset Label = "Calibration";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <45,194,195,244>;
    preset OnRelease = UpdateViewDebug;
    preset Label = "Debug";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <510,120,710,160>
  slot UpdateViewCalibration
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::Calibration, null, null, null, null, null, null, null, null, false );
  }

  $rect <510,160,710,200>
  slot UpdateViewDebug
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::Debug, null, null, null, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <45,77,195,127>;
    preset OnRelease = UpdateViewSettings;
    preset Label = "Settings";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <510,80,710,120>
  slot UpdateViewSettings
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::Settings, null, null, null, null, null, null, null, null, false );
  }
}

$rect <290,-110,490,-70>
$output false
class DistanceMeasurement : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,130,460,170>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,90,460,130>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,81>;
    preset String = "Distance\nMeasurement";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset Icon = Application::HomeIcon;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <25,96,225,146>;
    preset Outlet = ^Application::Device.Distance;
    preset MaxValue = 200;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar1
  {
    preset Bounds = <25,176,225,226>;
    preset Outlet = ^Application::Device.Angle;
    preset MaxValue = 90;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Bounds = <47,144,194,176>;
    preset Outlet = ^Application::Device.Distance;
    preset Unit = "mm";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay1
  {
    preset Bounds = <87,226,153,258>;
    preset Outlet = ^Application::Device.Angle;
    preset Unit = "°";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <260,200,460,240>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }
}

$rect <550,-120,750,-80>
$output false
resource Resources::Bitmap ZhawLogo
{
  attr bitmapfile FileName = .\pictures\ZHAW_Logo.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Appearance
note group Buttons
{
  attr Bounds = <800,-280,1170,-80>;
}

$rect <550,-160,750,-120>
$output false
resource Resources::Font MenuButtonFont
{
  attr fontname FontName = Arial;
  attr fontheight Height = 22;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <550,-80,750,-40>
$output false
resource Resources::Bitmap WarnSign
{
  attr bitmapfile FileName = .\pictures\industrial-security-1492062.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <290,-30,490,10>
$output false
class Menu : Core::Group
{
  $rect <320,10,520,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <320,110,520,150>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <320,70,520,110>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <480,300,1260,620>;
  }

  $rect <550,10,750,50>
  slot UpdateViewDetector
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::DetectorScreen, null, null, null, null, null, null, null, null, false );
  }

  $rect <550,50,750,90>
  slot UpdateViewDistance
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::DistanceMeasurement, null, null, null, null, null, null, null, null, false );
  }

  $rect <550,90,750,130>
  slot UpdateViewCurrent
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::CurrentMeasurement, null, null, null, null, null, null, null, null, false );
  }

  $rect <550,130,750,170>
  slot UpdateViewUtilities
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::Utilities, null, null, null, null, null, null, null, null, false );
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,51>;
    preset String = "Menu";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton CurrentButton
  {
    preset Bounds = <0,225,120,320>;
    preset OnRelease = UpdateViewCurrent;
    preset Label = "Current";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton DistanceButton
  {
    preset Bounds = <120,130,240,225>;
    preset OnRelease = UpdateViewDistance;
    preset Label = "Distance";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton DetectorButton
  {
    preset Bounds = <0,130,120,225>;
    preset OnRelease = UpdateViewDetector;
    preset Label = "Detector";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SettingsButton
  {
    preset Bounds = <120,225,240,320>;
    preset OnRelease = UpdateViewUtilities;
    preset Label = "Utilities";
    preset Appearance = WidgetSet::PushButton_Medium;
  }
}

$rect <830,150,1030,190>
inline Inline
{
  /*

    TO DO:

    Include external header files or add type and function declarations needed
    in the implementation of Application::DeviceClass. For example:

      #include "DeviceDriver.h"

      #include "your_middleware_api.h"

      void Your_Middleware_Some_Function( int aSomeArg );

  */

  #include "DeviceDriver.h"
}

$rect <830,110,1030,150>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <30,80,230,120>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Application::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <30,40,230,80>
  inherited method Init()
  {
    // The following section is intended to perform initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. register the object by the middleware as receiver of events, etc.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           initialization steps. For example, you invoke some 'C' function:

             YourDevice_Initialize();

           The variable 'thisObject' represents the actually initialized instance of the
           Application::DeviceClass. You can store this variable e.g. in the middleware
           and use it whenever the middleware needs to notify the GUI application about
           some state alternation or events. In this manner, the middleware will be able
           to invoke methods of the interface device object.

           For example, you can store 'thisObject' in some global C variable:

             // Declaration of the global C variable
             XObject theDeviceObject;

             // Store the instance in the global variable
             theDeviceObject = thisObject;

           Later use the global variable e.g. to provide the GUI application with events:

             ApplicationDeviceClass__TriggerSomeEvent( theDeviceObject );

           IMPORTANT:
           ----------

           If you store 'thisObject' for later use, don't forget to implement the opposite
           operation in the method 'Done'. Concrete, 'Done' should set the global variable
           again to the value NULL.

        */
      }
    $endif
  }

  // Device classes are assembled from 'Commands', 'Properties' and 'System Events'. \
  // For this purpose use the following prepared templates from the Gallery folder \
  // 'Device':
  // 
  // Command - method to trigger actions in the underlying device or query data from \
  // the device.
  // 
  // Property - variable to represent or modify a setting or state value existing \
  // within the underlying device.
  // 
  // System Event - represents an event or notifications the underlying device may \
  // report.
  // 
  // For more details please visit: https://doc.embedded-wizard.de/device-class-and-device-driver
  note legend Note4
  {
    attr Bounds = <310,600,1400,770>;
  }

  // The method 'Init' is executed just in the moment when new instance of 'Application::DeviceClass' \
  // is created. It is suitable to:
  // - initialize the hardware represented by the interface.
  // - register the instance by the middleware to receive updates and events.
  // - open files, network connections or other system resources needed by the interface.
  // 
  // The method 'Done' is executed just in the moment when an instance of 'Application::DeviceClass' \
  // is disposed. It is suitable to:
  // - de-initialize the underlying hardware.
  // - de-register the instance from the underlying middleware.
  // - close files, network connections and other no longer needed system resources.
  // 
  // If your application case doesn't need the initialization or de-initialization, \
  // feel free to delete the methods 'Init' or/and 'Done'.
  note legend Note3
  {
    attr Bounds = <320,0,1100,220>;
  }

  note arrow Note2
  {
    attr Point1 = <250,50>;
    attr Point2 = <320,50>;
  }

  // Constructor and Destructor
  note group Note1
  {
    attr Bounds = <10,0,250,140>;
  }

  $rect <40,280,240,320>
  property bool Lamptest;

  $rect <40,320,240,360>
  onset Lamptest
  {
    // The value doesn't change - nothing to do.
    if ( pure Lamptest == value )
      return;

    // Remember the property's new value.
    pure Lamptest = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    $if !$prototyper
      native ( value )
      {
        if(value){
          DeviceDriver_SetLampTest();
        } else {
          DeviceDriver_DisableLampTest();
        }
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Lamptest;
  }

  $rect <270,280,470,320>
  property int32 Current = 0;

  $rect <500,280,700,320>
  property int32 Distance;

  $rect <730,280,930,320>
  property int32 Angle;

  $rect <270,320,470,360>
  $output true
  method void UpdateCurrent( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Current )
    {
      // Remember the new value in the internal memory of the property.
      pure Current = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Current;
    }
  }

  $rect <500,320,700,360>
  $output true
  method void UpdateDistance( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Distance )
    {
      // Remember the new value in the internal memory of the property.
      pure Distance = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Distance;
    }
  }

  $rect <730,320,930,360>
  $output true
  method void UpdateAngle( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Angle )
    {
      // Remember the new value in the internal memory of the property.
      pure Angle = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Angle;
    }
  }

  $rect <40,380,240,420>
  property int32 DebugHall1;

  $rect <40,420,240,460>
  $output true
  method void UpdateDebugHall1( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure DebugHall1 )
    {
      // Remember the new value in the internal memory of the property.
      pure DebugHall1 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^DebugHall1;
    }
  }

  $rect <270,380,470,420>
  property int32 DebugHall2;

  $rect <270,420,470,460>
  $output true
  method void UpdateDebugHall2( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure DebugHall2 )
    {
      // Remember the new value in the internal memory of the property.
      pure DebugHall2 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^DebugHall2;
    }
  }

  $rect <500,380,700,420>
  property int32 DebugPad1;

  $rect <500,420,700,460>
  $output true
  method void UpdateDebugPad1( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure DebugPad1 )
    {
      // Remember the new value in the internal memory of the property.
      pure DebugPad1 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^DebugPad1;
    }
  }

  $rect <730,380,930,420>
  property int32 DebugPad2;

  $rect <730,420,930,460>
  $output true
  method void UpdateDebugPad2( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure DebugPad2 )
    {
      // Remember the new value in the internal memory of the property.
      pure DebugPad2 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^DebugPad2;
    }
  }

  $rect <970,280,1170,320>
  property bool MainsDetected;

  $rect <970,320,1170,360>
  method void UpdateMainsDetected( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure MainsDetected )
    {
      // Remember the new value in the internal memory of the property.
      pure MainsDetected = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^MainsDetected;
    }
  }

  $rect <970,380,1170,420>
  property bool Precision;

  $rect <970,420,1170,460>
  onset Precision
  {
    // The value doesn't change - nothing to do.
    if ( pure Precision == value )
      return;

    // Remember the property's new value.
    pure Precision = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    $if !$prototyper
      native ( value )
      {
        if(value){
          DeviceDriver_SetPrecision(true);
        } else {
          DeviceDriver_SetPrecision(false);
        }
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Precision;
  }
}

$rect <1030,110,1230,150>
autoobject Application::DeviceClass Device;

// Device Interface
note group Note
{
  attr Bounds = <800,60,1260,260>;
}

// This autoobject provides the default customization for the 'analog gauge' widget \
// (WidgetSet::Gauge) in its medium size variant.
$rect <830,-230,1130,-190>
$output false
autoobject WidgetSet::GaugeConfig BlueGauge
{
  preset SwingElastic = false;
  preset SwingDuration = 300;
  preset TrackLeftRoundedStart = true;
  preset TrackLeftColor = #0064A6FF;
  preset TrackLeftThickness = 21.0;
  preset TrackLeftRadius = 70.0;
  preset NeedleMaxAngle = -45;
  preset NeedleMinAngle = 225;
  preset NeedlePivot = <-39,12>;
  preset Needle = Application::BlueNeedle;
  preset CenterOffset = <0,10>;
  preset Scale = WidgetSet::GaugeTrackMedium;
  preset WidgetMinSize = <171,151>;
}

// This autoobject provides the default customization for the 'push button' widget \
// (WidgetSet::PushButton) in its medium size variant.
$rect <830,-190,1130,-150>
$output false
autoobject WidgetSet::PushButtonConfig BluePushButton
{
  preset LabelColorActive = #FFFFFFFF;
  preset LabelColorFocused = #FFFFFFFF;
  preset LabelColorDisabled = #A8ABABFF;
  preset LabelColorDefault = #6C6E70FF;
  preset LabelMarginBottom = 6;
  preset LabelMarginTop = 6;
  preset LabelMarginRight = 6;
  preset LabelMarginLeft = 6;
  preset IconTintDisabled = #A8ABABAA;
  preset IconTintDefault = #6C6E70FF;
  preset IconMarginBottom = 6;
  preset IconMarginTop = 6;
  preset IconMarginRight = 6;
  preset IconMarginLeft = 6;
  preset LabelFont = Resources::FontMedium;
  preset FaceFrameActive = 3;
  preset FaceFrameFocused = 2;
  preset FaceFrameDisabled = 0;
  preset FaceFrameDefault = 1;
  preset FaceActive = Application::BlueNeedle;
  preset FaceFocused = Application::BlueNeedle;
  preset FaceDisabled = Application::BlueNeedle;
  preset FaceDefault = Application::BlueNeedle;
  preset WidgetMinSize = <34,34>;
}

$rect <550,-40,750,0>
$output false
resource Resources::Bitmap HomeIcon
{
  attr bitmapfile FileName = .\pictures\Home.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <550,0,750,40>
$output false
resource Resources::Bitmap BlueNeedle
{
  attr bitmapfile FileName = .\pictures\GaugeNeedleLarge_blue.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This autoobject provides the default customization for the 'horizontal value bar' \
// widget (WidgetSet::HorizontalValueBar) in its medium size variant.
$rect <830,-150,1130,-110>
$output false
autoobject WidgetSet::HorizontalValueBarConfig BlueValueBar
{
  preset TrackRightFrame = 0;
  preset TrackRight = WidgetSet::HorizontalValueBarMedium;
  preset TrackLeftFrame = 1;
  preset TrackLeft = WidgetSet::HorizontalValueBarMedium;
  preset WidgetMinSize = <45,30>;
}

$rect <70,-30,270,10>
$output false
class Debug : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,51>;
    preset String = "Debug";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <260,200,460,240>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset IconFrame = 12;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Bounds = <20,74,220,106>;
    preset Outlet = ^Application::Device.DebugHall1;
    preset Unit = "Hall1";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay1
  {
    preset Bounds = <20,115,220,147>;
    preset Outlet = ^Application::Device.DebugHall2;
    preset Unit = "Hall2";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay2
  {
    preset Bounds = <20,160,220,192>;
    preset Outlet = ^Application::Device.DebugPad1;
    preset Unit = "Pad1";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay3
  {
    preset Bounds = <20,199,220,231>;
    preset Outlet = ^Application::Device.DebugPad2;
    preset Unit = "Pad2";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }
}

$rect <70,-70,270,-30>
$output false
class Calibration : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,51>;
    preset String = "Calibration";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <260,200,460,240>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset IconFrame = 12;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,68,195,118>;
    preset OnRelease = OpenCalibrationDialog;
    preset Label = "Start";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <45,130,195,180>;
    preset Label = "Save";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <45,194,195,244>;
    preset Label = "Reset";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <510,80,710,120>
  slot OpenCalibrationDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::CalibrationWindow1, Application::FadeInOutCentered, null, null, null, null, null, null, null, false );
  }
}

$rect <70,70,270,110>
$output false
class CalibrationWindow1 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <74,49,174,79>;
    preset String = "2 mm";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow2, Application::SlideLeft, null, null, null, Application::SlideLeft, null, null, null, null, false );
  }
}

$rect <70,110,270,150>
$output false
class CalibrationWindow2 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <74,49,174,79>;
    preset String = "5 mm";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow3, Application::SlideLeft, null, null, null, Application::SlideLeft, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow1, Application::SlideRight, null, null, null, Application::SlideRight, null, null, null, null, false );
  }
}

$rect <70,150,270,190>
$output false
class CalibrationWindow3 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <74,49,174,79>;
    preset String = "10 mm";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow4, Application::SlideLeft, null, null, null, Application::SlideLeft, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow2, Application::SlideRight, null, null, null, Application::SlideRight, null, null, null, null, false );
  }
}

$rect <70,190,270,230>
$output false
class CalibrationWindow4 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <74,49,174,79>;
    preset String = "20 mm";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow5, Application::SlideLeft, null, null, null, Application::SlideLeft, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow3, Application::SlideRight, null, null, null, Application::SlideRight, null, null, null, null, false );
  }
}

$rect <290,70,490,110>
$output false
class CalibrationWindow5 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <74,49,174,79>;
    preset String = "50 mm";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow6, Application::SlideLeft, null, null, null, Application::SlideLeft, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow4, Application::SlideRight, null, null, null, Application::SlideRight, null, null, null, null, false );
  }
}

$rect <290,110,490,150>
$output false
class CalibrationWindow6 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "100 mm";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow7, Application::SlideLeft , null, null, null, Application::SlideLeft, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow5, Application::SlideRight, null, null, null, Application::SlideRight, null, null, null, null, false );
  }
}

$rect <290,150,490,190>
$output false
class CalibrationWindow7 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 8;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "200 mm";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow6, Application::SlideRight, null, null, null, Application::SlideRight, null, null, null, null, false );
  }
}

$rect <150,260,400,300>
$output false
autoobject Effects::SlideTransition SlideRight
{
  preset Alignment = Effects::DialogAlignment[AlignHorzCenter, AlignVertCenter];
  preset Direction = Core::Direction.Right;
}

$rect <150,300,400,340>
$output false
autoobject Effects::SlideTransition SlideLeft
{
  preset Direction = Core::Direction.Left;
}

$rect <150,340,400,380>
$output false
autoobject Effects::FadeInOutTransition FadeInOutCentered;

$rect <70,-110,270,-70>
$output false
class Settings : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,51>;
    preset String = "Settings";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <260,200,460,240>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset IconFrame = 12;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <25,64,215,114>;
    preset Outlet = ^Application::Device.Lamptest;
    preset Label = "Lamptest";
    preset Appearance = WidgetSet::Switch_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton1
  {
    preset Bounds = <25,110,215,160>;
    preset Outlet = ^Application::Device.Precision;
    preset Checked = false;
    preset Label = "Precision";
    preset Appearance = WidgetSet::Switch_Medium;
  }
}

// This component shows an example how to use ComboBox widgets.
$rect <837,-261,1037,-221>
$output false
class Example : Core::Group
{
  $rect <350,140,550,180>
  inherited property Bounds = <0,0,320,240>;

  $rect <20,560,220,600>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  // This example demonstrates the usage of the ComboBox:
  // 
  // - The ComboBox is connected to the both slot methods OnLoadItem and OnSelect.
  // 
  // - OnLoadItem will be called by the ComboBox to load the content of an item. \
  // Within the method you can initialize the item consequently.
  // 
  // - OnSelect will be called when the user has made a selection. Within the method \
  // you can evaluate which item has been selected.
  // 
  // Just press F5 to test the ComboBox.
  note legend Note1
  {
    attr Bounds = <10,270,860,430>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,320,240>;
  }

  $rect <20,20,160,60>
  object Application::ComboBox ComboBox
  {
    preset Bounds = <35,57,285,107>;
    preset OnSelect = OnSelect;
    preset OnLoadItem = OnLoadItem;
    preset SelectedItem = 0;
    preset NoOfItems = 10;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <35,2,285,57>;
    preset String = "";
    preset Font = Resources::FontLarge;
    preset Color = #C85C49FF;
  }

  $rect <350,30,550,70>
  slot OnLoadItem
  {
    var string name;

    // Which item should be loaded?
    switch ( ComboBox.View.Item )
    {
      case  0 : name = "Banana";
      case  1 : name = "Apple";
      case  2 : name = "Cherry";
      case  3 : name = "Strawberry";
      case  4 : name = "Pineapple";
      case  5 : name = "Orange";
      case  6 : name = "Kiwi";
      case  7 : name = "Blueberry";
      case  8 : name = "Melon";
      case  9 : name = "Mango";
      default : name = "???";
    }

    // Initialize the item
    ComboBox.View.String = name;
  }

  $rect <350,70,550,110>
  slot OnSelect
  {
    // The user has selected an item. Display its number.
    Text.String = "Selected option #" + string( ComboBox.SelectedItem );
  }
}

// This class implements the item component for the Application::ComboBox widget. \
// This class is used internally within Application::ComboBox widget and the associated \
// Application::ComboBoxList component. You will probably never need to directly \
// instantiate and control this item component.
$rect <837,-331,1037,-291>
$output false
class ComboBoxItem : Templates::ListItem
{
  $rect <250,270,450,310>
  inherited property Bounds = <0,0,200,40>;

  $rect <710,160,910,200>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the Item
    //
    // isMarked  --> the item is selected within the corresponding list.
    // isFocused --> the user has navigated to the item. The item can
    //               receive keyboard events.
    // isPressed --> the user presses the item actively.
    //
    //
    var bool isMarked  = Marked;
    var bool isFocused = aState.contains( Core::ViewState[ Focused ]);
    var bool isPressed = TouchHandler.Down || FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your Item design, you have surely added some new views
      to your component. In the below code you should update the properties
      of these views. For example, when your Item has two images to appear
      exclusively for pressed and not pressed state, following can be done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the Item, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size of the view, ...
       
      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the Item
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your Item component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the Item. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( isPressed )
    {
      Background.Color = #FF0000FF;
      Text.Color       = #FFFFFFFF;
      Border.Visible   = true;
      Border.Width     = 3;
    }

    else if ( isFocused && isMarked )
    {
      Background.Color = #FF0000FF;
      Text.Color       = #FFFFFFFF;
      Border.Visible   = true;
      Border.Width     = 1;
    }

    else if ( isFocused )
    {
      Background.Color = #FFAAAAFF;
      Text.Color       = #000000FF;
      Border.Visible   = true;
      Border.Width     = 1;
    }

    else if ( isMarked )
    {
      Background.Color = #FF0000FF;
      Text.Color       = #FFFFFFFF;
      Border.Visible   = false;
    }

    // Not marked nor selected.
    else
    {
      Background.Color = #FFFFFFFF;
      Text.Color       = #000000FF;
      Border.Visible   = false;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    focused = isFocused;
    marked  = isMarked;
    pressed = isPressed;
  }

  // To do:
  // 
  // - Adjust the visible size of your item (the thick blue border). This will be \
  // the item's default size.
  // - Resize the member 'TouchHandler' so it still fills the items's new area.
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your item.
  // - Remove the 'Text' view, 'String' property and the associated onset method \
  // if you don't want to display text.
  // - According to your desired item design add and configure new views (e.g. an \
  // image view to show an icon or a further text view to show additional text, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the item's current state.
  // - You can also add and configure animation effects to your item. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your item.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the item itself is resized.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // item to be activated with key other than the 'Enter' key.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your item. One property \
  // for every item specific setting (e.g. 'Icon', 'Color', 'Font', ...).
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your item where \
  // the icon is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,340,1010,710>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,120,920,330>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,120,690,250>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,120,460,250>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,120,230,250>;
  }

  // This variable stores the current state of the item.
  $rect <710,280,910,320>
  var bool pressed;

  // This variable stores the current state of the item.
  $rect <710,240,910,280>
  var bool focused;

  // This variable stores the current state of the item.
  $rect <710,200,910,240>
  var bool marked;

  // This timer object is used to flash the item when the user has tapped it very \
  // quickly or the item has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,160,680,200>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,160,450,200>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,200,680,240>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the item to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the item is activated.
    postsignal OnSelect;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,200,450,240>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the item via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the item for a short period. This is a kind of 
    // feedback effect. Request the item to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the item. This only updates the item to appear pressed or released.
  $rect <20,200,220,240>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the item or drags the finger inside/outside
    // the item's area request the item update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the item's area. This activates the item.
  $rect <20,160,220,200>
  slot onReleaseTouch
  {
    // Every time the user releases the item, request an update. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the item for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The item can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnSelect;

    // The user has tapped the item very quickly. Defer the item activation
    // to give the user first a short visual feedback that the item has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  $rect <240,50,440,90>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the property's new value.
    pure String = value;

    // ... and update the Text view.
    Text.String = value;
  }

  $rect <440,50,640,90>
  onset Marked
  {
    // The value doesn't change - nothing to do.
    if ( pure Marked == value )
      return;

    // Remember the property's new value.
    pure Marked = value;

    // Request the view to update its state
    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,200,40>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,200,40>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,5,195,35>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzAuto, AlignVertCenter];
    preset String = "Text";
    preset Font = Resources::FontMedium;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,40>;
    preset Point3 = <200,40>;
    preset Point2 = <200,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnSelect' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the item (selected the item). Thereupon the \
  // method's logic will be executed.
  $rect <640,50,840,90>
  property slot OnSelect = null;

  // The property 'Item' stores the number of the item within the ComboBox. The first \
  // item has the number 0. The second 1, and so far.
  $rect <640,10,840,50>
  property int32 Item = -1;

  // The property 'Marked' stores the state of the item. If this property is 'true', \
  // the item appears as selected.
  $rect <440,10,640,50>
  property bool Marked = false;

  // The property 'String' stores the text to display in the item.
  $rect <240,10,440,50>
  property string String = "Text";
}

// This class implements the list component for the Application::ComboBox widget. \
// When the user activates the ComboBox, the list component is shown displaying all \
// available options and permitting the user to select the desired option.
// The class Application::ComboBoxList is used internally within Application::ComboBox \
// widget. You will probably never need to directly instantiate and control this \
// list component.
$rect <837,-371,1037,-331>
$output false
class ComboBoxList : Templates::List
{
  $rect <700,220,900,260>
  inherited method CursorHitTest()
  {
    // First perform the cursor-hit test as usual.
    var Core::CursorHit hit = super( aArea, aFinger, aStrikeCount, aDedicatedView, aRetargetReason );

    // Now, has the user tapped outside the list component? This can cause the list to disappear.
    // Inform the ComboBox in such case.
    if ( !hit && !aDedicatedView && ( aArea & Bounds ).isempty )
      postsignal onCloseList;

    return hit;
  }

  $rect <10,270,210,310>
  inherited property Bounds = <0,0,200,200>;

  $rect <240,280,440,320>
  inherited method UpdateLayout()
  {
    super( aSize );

    // Just in the moment when the List appears or its size changes, 
    // ensure that there is no empty space in the list.
    VerticalList.AdjustList( null, null );

    // Then eventually scroll the list so the actually selected item
    // is fully visible.
    VerticalList.EnsureVisible( selectedItem, true, null, null );

    // The following operation additionally adjusts the scrolling so
    // the list snaps at the edge of the first visible item.
    var int32 firstVisibleItem = VerticalList.GetItemAtPosition( VerticalList.Bounds.origin );
    VerticalList.EnsureVisible( firstVisibleItem, true, null, null );
  }

  // To do:
  // 
  // - Remove the 'Background' and 'Border' members if you want other views to be \
  // shown instead these in your list.
  // - According to your desired list design add and configure new views (e.g. a \
  // bitmap frame view to show the list border being composed of images, etc.).
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your list.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the list itself is resized.
  // - Eventually move/resize the 'VerticalList' and the 'SlideTouchHandler' members \
  // if you want larger/smaller borders.
  // - Configure the property 'Filter' of the 'KeyUpHandler', 'KeyDownHandler' and \
  // 'KeyEscapeHandler' members if you want the list to be controlled by other keys \
  // than the 'UP', 'DOWN', 'ESCAPE' keys.
  // - Alternatively remove all key handlers and 'onKey' slot methods if you don't \
  // want any keyboard handling.
  // - Adapt the method Initialize(). It calculates the size and position of the \
  // list depending on the position  of the ComboBox.
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note5
  {
    attr Bounds = <10,340,990,590>;
  }

  // Touch Handling
  note group Note4
  {
    attr Bounds = <690,170,910,280>;
  }

  // List functionality
  note group Note3
  {
    attr Bounds = <460,170,680,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <460,20,1080,160>;
  }

  // Initialization
  note group Note1
  {
    attr Bounds = <230,20,450,330>;
  }

  // This variable refers to a slot method in the ComboBox to invoke when the user \
  // has decided to close the List without making any selection.
  $rect <240,230,440,270>
  var slot onCloseList;

  // This variable refers to a slot method in the ComboBox to invoke when the user \
  // has made a selection within the List.
  $rect <240,190,440,230>
  var slot onSelectItem;

  // This variable refers to a slot method in the ComboBox the List component will \
  // invoke in order to load an item with its appropriate content. In such case the \
  // sender of the signal will refer the item in question.
  $rect <240,150,440,190>
  var slot onLoadItem;

  // This variable stores which item was selected just in the moment when the user \
  // has activated the ComboBox List. This item will consequently appear as selected \
  // within the List.
  $rect <240,110,440,150>
  var int32 selectedItem;

  // This internal slot method is called by the embedded 'VerticalList' in order \
  // to load a list item with its appropriate content. The invocation is relayed \
  // to the ComboBox.
  $rect <470,220,670,260>
  slot onLoadItemSlot
  {
    // Access the item view intended to be loaded now.
    var Application::ComboBoxItem view = (Application::ComboBoxItem)VerticalList.View;

    // Ensure, the item view is correctly connected with the ComboBox.
    view.OnSelect = onSelectItem;

    // Which number has the item and is the item the originally 'selected' one?
    view.Item   = VerticalList.Item;
    view.Marked = view.Item == selectedItem;

    // Also ensure that the item fills the list horizontally.
    view.Bounds.w = VerticalList.Bounds.w;

    // Forward the signal to the ComboBox's OnLoadItem slot method. This method is then
    // responsible for the proper initialization of the item's content. Use the item 
    // view as 'sender' of the signal.
    signal onLoadItem, view;
  }

  // This internal slot method is called when the '@KeyEscapeHandler' is activated \
  // (when the user has pressed the key specified in the property 'Filter' of the \
  // key handler).
  $rect <870,100,1070,140>
  slot onKeyEscape
  {
    // The user has pressed the ESCAPE key. Inform the ComboBox about the close operation.
    postsignal onCloseList;
  }

  // This internal slot method is called when the '@KeyDownHandler' is activated \
  // (when the user has pressed the key specified in the property 'Filter' of the \
  // key handler).
  $rect <670,100,870,140>
  slot onKeyDown
  {
    // No more following items?
    if ( VerticalList.SelectedItem >= ( VerticalList.NoOfItems - 1 ))
      return;

    // Select the next following item and ensure it is visible.
    VerticalList.SelectedItem++;
    VerticalList.EnsureVisible( VerticalList.SelectedItem, true, null, null );
  }

  // This internal slot method is called when the '@KeyUpHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <470,100,670,140>
  slot onKeyUp
  {
    // No more preceding items
    if ( VerticalList.SelectedItem <= 0 )
      return;

    // Select the preceding item and ensure it is visible.
    VerticalList.SelectedItem--;
    VerticalList.EnsureVisible( VerticalList.SelectedItem, true, null, null );
  }

  // This key handler reacts to key ESCAPE events. When the user presses the key \
  // ESCAPE (specified in the property 'Filter' of the key handler), the handler \
  // is activated and the method '@onKeyEscape' is called.
  $rect <870,60,1070,100>
  object Core::KeyPressHandler KeyEscapeHandler
  {
    preset OnPress = onKeyEscape;
    preset Filter = Core::KeyCode.Escape;
  }

  // This key handler reacts to key DOWN events. When the user presses the key DOWN \
  // (specified in the property 'Filter' of the key handler), the handler is activated \
  // and the method '@onKeyDown' is called.
  $rect <670,60,870,100>
  object Core::KeyPressHandler KeyDownHandler
  {
    preset OnPress = onKeyDown;
    preset Filter = Core::KeyCode.Down;
    preset OnHold = onKeyDown;
  }

  // This key handler reacts to key UP events. When the user presses the key UP (specified \
  // in the property 'Filter' of the key handler), the handler is activated and the \
  // method '@onKeyUp' is called.
  $rect <470,60,670,100>
  object Core::KeyPressHandler KeyUpHandler
  {
    preset OnPress = onKeyUp;
    preset Filter = Core::KeyCode.Up;
    preset OnHold = onKeyUp;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,200,200>;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,200,200>;
    preset Width = 3;
    preset Color = #444444FF;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,5,195,195>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <5,5,195,195>;
    preset OnLoadItem = onLoadItemSlot;
    preset SlideHandler = SlideTouchHandler;
    preset ItemClass = Application::ComboBoxItem;
  }

  // This method is called just in the moment when the user activates the ComboBox. \
  // Its task is to initialize the List component according to the parameters found \
  // in the ComboBox. It also calculates the optimal size/position for the list and \
  // connects the List to the ComboBox.
  $rect <240,60,440,100>
  method void Initialize( arg rect aComboBoxArea, arg point aScreenSize, arg int32 aNoOfItems, arg int32 aSelectedItem, arg slot aOnLoadItem, arg slot aOnSelectItem, arg slot aOnCloseList )
  {
    // Remember 'callbacks' the list should use to communicate with the ComboBox.
    onLoadItem   = aOnLoadItem;
    onSelectItem = aOnSelectItem;
    onCloseList  = aOnCloseList;

    // Initialize the list according to the passed parameters.
    VerticalList.NoOfItems    = aNoOfItems;
    VerticalList.SelectedItem = aSelectedItem;

    // Also remember which item was originally selected.
    selectedItem = aSelectedItem;

    // To get the item height, create temporarily a new instance of the associated 
    // item class and query its default size.
    VerticalList.ItemHeight = ((Core::RectView)new VerticalList.ItemClass ).Bounds.h;

    // Also the Slide Touch Handler should be configure to snap at item edges.
    SlideTouchHandler.SnapNext.y = VerticalList.ItemHeight;

    // Now estimate the width of the list. Usually, the width of the list should 
    // correspond to the width of the ComboBox. The list should also be aligned at
    // the left edge of the ComboBox.
    var int32 w = aComboBoxArea.w;
    var int32 x = aComboBoxArea.x1;

    // Now estimate the height of the list. Let's assume, the list is large enough
    // to display all items at once. The list should also appear just below the
    // ComboBox.
    var int32 h = VerticalList.NoOfItems * VerticalList.ItemHeight;
    var int32 y = aComboBoxArea.y2;

    // Ensure the list is not too large. Here, we limit the list to 1/3 of the entire
    // screen height.
    h = math_min( h, aScreenSize.y / 3 );

    // Adjust the height so that it is a multiple of the height of a single item.
    h -= h % VerticalList.ItemHeight;

    // Take in account the evtl. existing decorations or borders around the list, etc.
    h += Bounds.h - VerticalList.Bounds.h;

    // Now verify, whether there is sufficient space below the ComboBox to display
    // the list. If not, the list will appear above the ComboBox.
    if (( aScreenSize.y - aComboBoxArea.y2 ) < h )
      y = aComboBoxArea.y1 - h;

    // Adjust the size and position of the list.
    Bounds = rect( x, y, x + w, y + h );
  }
}

// This class implements a 'combo box' widget. When the user activates the box, an \
// associated Application::ComboBoxList component is shown displaying all available \
// options and permitting the user to select the desired option. Selecting the option \
// sends a signal to the slot method stored in the property @OnSelect.
// Alternatively the property @Outlet can refer to any other 'int32' property the \
// widget should remain synchronized with. When the user selects an option, the affected \
// property is automatically updated to reflect the number of the selected option. \
// On the other hand, when the referred property is modified by another one, the \
// ComboBox is automatically notified to remain in sync with the property.
// The total number of available ComboBox items (the number of options) is determined \
// by the property @NoOfItems. Which option is actually selected is controlled by \
// the property @SelectedItem.
// The items are loaded dynamically at the runtime. For this purpose a slot method \
// has to be implemented and assigned to the @OnLoadItem property. The ComboBox will \
// invoke the slot method automatically each time it needs an item to be loaded. \
// Within the slot method the implementation can access and initialize the affected \
// item by using the variable @View.
// In order to trigger the combo box to reload one or more items, invoke the method \
// @InvalidateItems(). The box will thereupon schedule the necessary loading steps \
// automatically.
$rect <837,-411,1037,-371>
$output false
class ComboBox : Templates::ComboBox
{
  $rect <20,370,220,410>
  inherited property Bounds = <0,0,250,50>;

  $rect <710,230,910,270>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // If not yet existing - create and initialize the view representing
    // the actually selected item in the ComboBox. It is a single item view
    // similarly to the used within the associated list.
    if ( !previewItem )
    {
      // Create a new item view
      previewItem = new Application::ComboBoxItem;

      previewItem.Enabled = false;
      previewItem.Item    = SelectedItem;
      previewItem.Layout  = Core::Layout[ AlignToLeft, AlignToRight, AlignToTop,
                                          AlignToBottom, ResizeHorz ]; 

      // Load the item view with data corresponding to the actually selected
      // item.
      View = previewItem;
      signal OnLoadItem;
      View = null;

      // Query the default size of an item
      var point size = previewItem.Bounds.size;

      // Arrange the item view so that it fills the ComboBox area excepting
      // the arrow image on the right of the ComboBox. The height of the item
      // should not change.
      previewItem.Bounds = rect( 3, Bounds.h / 2 - size.y / 2, Image.Bounds.x1,
                                 Bounds.h / 2 + size.y / 2 );

      // Finally adding the view to the ComboBox makes it visible
      Add( previewItem, 0 );

      // Avoid that the view appears selected as selected views do within the
      // list.
      Focus = null;
    }

    // Determine the new state of the ComboBox
    //
    // isEnabled  --> the box can react to user inputs.
    // isSelected --> the box can receive keyboard events.
    // isPressed  --> the box should appear pressed.
    // isOpened   --> the associated list is visible actually.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;
    var bool isOpened   = list != null;

    /*

      TO DO:

      Depending on your ComboBox design, you have surely added some new views
      to your box. In the below code you should update the properties of these
      views. For example, when your ComboBox has two images to appear
      exclusively for released and pressed box state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the box, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the box
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your ComboBox component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the box. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background1.Color   = #FFFFFFFF;
      Background2.Visible = false;
      Border.Color        = #CCCCCCFF;
      Border.Width        = 1;
      Image.FrameNumber   = 1;
      Image.Color         = #AAAAAAFF;
      previewItem.Opacity = 128;
    }

    else if ( isOpened )
    {
      Background1.Color   = #FFFFFFFF;
      Background2.Visible = false;
      Border.Color        = #444444FF;
      Border.Width        = 1;
      Image.FrameNumber   = 0;
      Image.Color         = #000000FF;
      previewItem.Opacity = 255;
    }

    else if ( isPressed )
    {
      Background1.Color   = #FFFFFFFF;
      Background2.Visible = true;
      Border.Color        = #000000FF;
      Border.Width        = 3;
      Image.FrameNumber   = 1;
      Image.Color         = #FFFFFFFF;
      previewItem.Opacity = 255;
    }

    else if ( isSelected )
    {
      Background1.Color   = #FFFFFFFF;
      Background2.Visible = false;
      Border.Color        = #444444FF;
      Border.Width        = 3;
      Image.FrameNumber   = 1;
      Image.Color         = #000000FF;
      previewItem.Opacity = 255;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background1.Color   = #FFFFFFFF;
      Background2.Visible = false;
      Border.Color        = #444444FF;
      Border.Width        = 1;
      Image.FrameNumber   = 1;
      Image.Color         = #000000FF;
      previewItem.Opacity = 255;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;
    opened   = isOpened;
  }

  // To do:
  // 
  // - Adjust the visible size of your ComboBox (the thick blue border). This will \
  // be the widget's default size.
  // - Resize the member 'TouchHandler' so it still fills the widget's new area.
  // - Remove the 'Background1', 'Background2' and/or 'Border' members if you want \
  // other views to be shown instead these in your ComboBox.
  // - According to your desired ComboBox design add and configure new views (e.g. \
  // an image view to show the icon or a text view to show a caption, etc.).
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the widget's current state.
  // - You can also add and configure animation effects to your ComboBox. See 'UpdateViewState()' \
  // implementation for hint how to start the effects.
  // - Arrange and resize the views so they appear correctly within the visible area \
  // of your ComboBox.
  // - Configure the property 'Layout' of the views. In this manner you can determine \
  // for every view how it should move/resize when the widget itself is resized.
  // - Configure the property 'Filter' of the 'KeyHandler' member if you want the \
  // ComboBox to be activated with key other than the 'Enter' key.
  // - Alternatively remove the members 'KeyHandler' and 'onPressKey' if you don't \
  // want any keyboard handling.
  // - Configure the property 'Begin' of the 'FlashTimer' member to change the duration \
  // of the feedback flash effect. The default duration is 50 millisec.
  // - From the Gallery folder 'Chora' add properties to your ComboBox. One property \
  // for every specific setting (e.g. 'Caption', 'Icon', 'Color', 'Font', ...)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'Icon' should update the image view in your ComboBox where \
  // the icon is shown).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note7
  {
    attr Bounds = <10,570,990,950>;
  }

  // List Functionality
  note group Note6
  {
    attr Bounds = <930,190,1150,560>;
  }

  // Controller events
  note group Note5
  {
    attr Bounds = <240,330,460,420>;
  }

  // State management
  note group Note4
  {
    attr Bounds = <700,190,920,480>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,190,690,320>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,190,460,320>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,190,230,320>;
  }

  // This variable stores an animation effect used to show/hide the list.
  $rect <940,510,1140,550>
  var Effects::Effect effect;

  // This variable stores the List component if its is visible actually.
  $rect <940,470,1140,510>
  var Application::ComboBoxList list;

  // This variable stores an item instance used in the ComboBox to show the actual \
  // selection.
  $rect <710,430,910,470>
  var Application::ComboBoxItem previewItem;

  // This variable stores the current state of the ComboBox.
  $rect <710,390,910,430>
  var bool opened;

  // This variable stores the current state of the ComboBox.
  $rect <710,350,910,390>
  var bool pressed;

  // This variable stores the current state of the ComboBox.
  $rect <710,310,910,350>
  var bool selected;

  // This variable stores the current state of the ComboBox.
  $rect <710,270,910,310>
  var bool enabled;

  // This timer object is used to flash the ComboBox when the user has tapped it \
  // very quickly or the ComboBox has been activated with the keyboard. This is just \
  // a visual feedback effect.
  $rect <480,230,680,270>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,230,450,270>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the list has finished its fade-in/out \
  // animation.
  $rect <940,430,1140,470>
  slot onEndFadeOutEffect
  {
    var Core::Root root = (Core::Root)list.Owner;

    // End the modal state of the list and remove it from the application.
    root.Remove( list );
    root.EndModal( list );
    list = null;

    // Release the effect object
    effect = null;

    // Trigger an update in the ComboBox to reflect the new state.
    InvalidateViewState();
  }

  // This internal slot method is called when the list has finished its fade-in/out \
  // animation.
  $rect <940,390,1140,430>
  slot onEndFadeInEffect
  {
    // Release the effect object
    effect = null;
  }

  // This internal slot method is called when the user has made a selection in the \
  // List or decided to close the list without any selection. Thereupon the list \
  // disappears.
  $rect <940,350,1140,390>
  slot onCloseList
  {
    // The list is already closed.
    if ( !list )
      return;

    /*

      HINT :

      Following code uses an animation effect to fade-out the list when it closed.
      If you don't want such animation, you can remove the code till the end of
      the method and replace it by following code:

      var Core::Root root = GetRoot();

      root.Remove( list );
      root.EndModal( list );
      list = null;

      InvalidateViewState();

    */

    // If there is already an effect running, stop it first.
    if ( effect )
      effect.Enabled = false;

    // Create a new effect object to animate the list when it is hidden. In this
    // template the animation modulates the opacity of the list.
    var Effects::Int32Effect int32Effect = new Effects::Int32Effect;

    // Configure the animation and start it
    int32Effect.Value1        = list.Opacity;
    int32Effect.Value2        = 0;
    int32Effect.CycleDuration = 150;
    int32Effect.NoOfCycles    = 1;
    int32Effect.Outlet        = ^list.Opacity;
    int32Effect.OnFinished    = onEndFadeOutEffect;
    int32Effect.Enabled       = true;
    effect                    = int32Effect;
  }

  // This internal slot method is called when the user has made a selection within \
  // the List component. Thereupon the ComboBox is updated and the List is hidden.
  $rect <940,310,1140,350>
  slot onSelectItem
  {
    // The list is already closed.
    if ( !list )
      return;

    // Making a selection within the ComboBox closes the list.
    postsignal onCloseList;

    // Obtain access to the just selected item
    var Application::ComboBoxItem item = (Application::ComboBoxItem)sender;

    // If the selection did not change?
    if ( SelectedItem == item.Item )
      return;

    // Update the ComboBox to reflect the new selection
    SelectedItem = item.Item;

    // Inform the owner of the ComboBox about the made selection.
    postsignal OnSelect;

    // ... and if there is an associated Outlet, update it too
    if ( Outlet )
      Outlet^ = item.Item;
  }

  // This internal slot method is called when the actually displayed List component \
  // needs to update an item. The invocation is relayed to the slot method stored \
  // in the property @OnLoadItem.
  $rect <940,270,1140,310>
  slot onLoadItem
  {
    // Obtain access to the item for which the load operation is performed
    var Application::ComboBoxItem item = (Application::ComboBoxItem)sender;

    // ...and forward the signal to the OnLoadItem slot method. This method is then
    // responsible for the proper initialization of the item.
    View = item;
    signal OnLoadItem;
    View = null;
  }

  // This internal slot method is called when the user has activated the ComboBox. \
  // It creates a new instance of the respective List component and displays it.
  $rect <940,230,1140,270>
  slot onShowList
  {
    // Avoid race conditions caused by the delay of 'FlashTimer'. Due to the delay
    // the method 'onShowList' may become invoked twice. Thus ignore the second
    // invocation if there is already a list visible.
    if ( list )
      return;

    var Core::Root root   = GetRoot();
    var rect       bounds = Bounds;

    // Calculate the screen global position of the ComboBox
    bounds.origin = Owner.GlobalPosition( bounds.origin );

    // Create a new instance of the ComboBox List component and ...
    list = new Application::ComboBoxList;

    // ... initialize it, calculate its optimal size and position, etc.
    list.Initialize( bounds, root.Bounds.size, NoOfItems, SelectedItem, onLoadItem, 
                     onSelectItem, onCloseList );

    /*

      HINT :

      Following code uses an animation effect to fade-in the list when it shown.
      If you don't want such animation, you can remove the code till the end of
      the method and replace it by following code:

      root.Add( list, 0 );
      root.BeginModal( list );

      InvalidateViewState();

    */

    // If there is already an effect running, stop it first.
    if ( effect )
      effect.Enabled = false;

    // Create a new effect object to animate the list when it is shown. In this
    // template the animation changes the size of the list.
    var Effects::RectEffect rectEffect = new Effects::RectEffect;

    // Configure the animation. 
    rectEffect.Value1        = list.Bounds;
    rectEffect.Value2        = list.Bounds;
    rectEffect.CycleDuration = 150;
    rectEffect.Timing        = Effects::Timing.FastIn_EaseOut;
    rectEffect.NoOfCycles    = 1;
    rectEffect.Outlet        = ^list.Bounds;
    rectEffect.OnFinished    = onEndFadeInEffect;

    // Adjust the animation for the case, when the list should appear below the
    // combo box
    if ( list.Bounds.y1 > bounds.y1 )
      rectEffect.Value1.y2 = rectEffect.Value1.y1;

    // ... or above the combo box
    else
      rectEffect.Value1.y1 = rectEffect.Value1.y2;

    // ... and start the animation
    rectEffect.Enabled = true;
    effect             = rectEffect;

    // Make the list visible and modal
    root.Add( list, 0 );
    root.BeginModal( list );

    // Trigger the ComboBox to eventually adapt its appearance after the list is shown.
    InvalidateViewState();
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <250,370,450,410>
  slot onOutlet
  {
    // Read the current value of the associated property and update accordingly
    // the state of the ComboBox.
    if ( Outlet != null )
      SelectedItem = Outlet^;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,270,680,310>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the ComboBox to update
    // its appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the associated list is shown
    postsignal onShowList;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,270,450,310>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the ComboBox via
    // the touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the ComboBox for a short period. This is a kind
    // of feedback effect. Request the ComboBox to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The ComboBox is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the box or presses the key in
    // a very rapid succession. Thus ignore this new interaction.
    if ( FlashTimer.Enabled )
      return;

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the ComboBox. This only updates the box to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the ComboBox or drags the finger inside/outside
    // the box's area request the ComboBox update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the ComboBox's area. This activates the ComboBox.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the ComboBox area? In such case
    // the ComboBox is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the ComboBox for longer time. This was 
    // enough long to give a visual 'press' feedback to the user. The box can
    // be activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal onShowList;

    // The user has tapped the ComboBox very quickly. Defer the box activation
    // to give the user first a short visual feedback that the ComboBox has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background1
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,250,50>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background2
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <200,0,250,50>;
    preset Color = #FF0000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Border Border
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,250,50>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,50>;
    preset Point3 = <250,50>;
    preset Point2 = <250,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToRight, AlignToTop, ResizeVert];
    preset Bounds = <200,0,250,50>;
    preset Color = #000000FF;
    preset FrameNumber = 1;
    preset Bitmap = Resources::NavigationIconsLarge;
  }

  $rect <690,50,890,90>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  $rect <490,50,690,90>
  onset SelectedItem
  {
    // Ensure the index of the selected item is valid
    if ( value < 0 )
      value = -1;

    // No changes - nothing to do
    if ( value == pure SelectedItem )
      return;

    // Remember the new item
    pure SelectedItem = value;

    // Changing the selection at the runtime forces the ComboBox to recreate
    // its preview item.
    if ( previewItem )
    {
      Remove( previewItem );
      previewItem = null;
    }

    // Request an update
    InvalidateViewState();
  }

  $rect <290,50,490,90>
  onset NoOfItems
  {
    // Ensure the given number of items is valid
    if ( value < 0 )
      value = 0;

    // No changes - nothing to do
    if ( value == pure NoOfItems )
      return;

    // Remember the new number of items
    pure NoOfItems = value;

    // Changing the number of items may affect the actually selected item.
    // Therefore recreate the preview item of the ComboBox.
    if ( previewItem )
    {
      Remove( previewItem );
      previewItem = null;
    }

    // Request an update
    InvalidateViewState();
  }

  // The method InvalidateItems() forces the combo box to reload one or more items. \
  // The index of the item to start the reload operation is specified in the parameter \
  // aFirstItem. The parameter aLastItem specifies the index of the last affected \
  // item. The first item has the index 0, the second 1, and so far. The operation \
  // can cause the combo box to invoke the external @OnLoadItem slot method for each \
  // affected item.
  $rect <490,100,690,140>
  method void InvalidateItems( arg int32 aFirstItem, arg int32 aLastItem )
  {
    // If there is actually a list box displayed, forward the request to its
    // embedded vertical list.
    if ( list )
      list.VerticalList.InvalidateItems( aFirstItem, aLastItem );

    // The request also forces the ComboBox to recreate its preview item if the
    // invalidated items affect the actually selected item.
    if ( previewItem && ( SelectedItem >= aFirstItem ) && ( SelectedItem <= aLastItem ))
    {
      Remove( previewItem );
      previewItem = null;

      // Request an update
      InvalidateViewState();
    }
  }

  // The variable 'View' refers to the item which is about to be loaded by the external \
  // slot method @OnLoadItem. In this manner the slot method can directly access \
  // and modify the item's properties.
  $rect <290,140,490,180>
  var Application::ComboBoxItem View;

  // The property 'OnSelect' can refer to a slot method, which will receive a signal \
  // each time the user has selected an item within the ComboBox. Thereupon the method's \
  // logic will be executed. In the associated slot method you can evaluate @SelectedItem \
  // to process the selection.
  $rect <690,100,890,140>
  property slot OnSelect = null;

  // The property 'OnLoadItem' should refer to a slot method, which will be invoked \
  // by the ComboBox in order to load an item with its corresponding content. Within \
  // the slot method the affected item can be accessed via variable @View.
  $rect <290,100,490,140>
  property slot OnLoadItem = null;

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the user selects an item, the affected property \
  // is automatically updated to reflect the item's number. On the other hand, when \
  // the referred property is modified by another one, the ComboBox is automatically \
  // notified to remain in sync with the property.
  // This approach follows the Model-View-Controller (MVC) programming paradigm. \
  // Here the ComboBox represents the 'View' and 'Controller' and the property referred \
  // via 'Outlet' can be seen as a part of the 'Model'.
  $rect <690,10,890,50>
  property ^int32 Outlet = null;

  // The property 'SelectedItem' stores the index of the currently selected item \
  // or -1 if no item is selected. The first item has the index 0, the second 1, \
  // and so far.
  $rect <490,10,690,50>
  property int32 SelectedItem = -1;

  // The property 'NoOfItems' stores how many items are currently managed within \
  // the ComboBox. This value should correspond to the number of options the ComboBox \
  // offers to the user.
  $rect <290,10,490,50>
  property int32 NoOfItems = 0;
}

// This is a 'ComboBox' widget template. It is intended to help you to implement \
// your own specific ComboBoxes. The ComboBox is composed of three components:
// 
// - Application::ComboBox implements the ComboBox itself.
// - Application::ComboBoxList implements the list shown when the user activates \
// the ComboBox.
// - Application::ComboBoxItem implements the item used within the ComboBox.
// 
// Open the components and do following:
// 
// - Change the appearance of the item, list and ComboBox according to your design.
// - Add properties to allow the ComboBox instances to be configured.
// - Optionally, modify the default behavior of the components.
// 
// More hints inside the components ...
// 
// Also please note the provided Application::Example component. It demonstrates \
// the usage of the ComboBox. If not desired, you can delete Application::Example.
note legend Note1
{
  attr Bounds = <1047,-411,1697,-101>;
}
