$version 11.00

// This is the root component of the entire GUI application.
$rect <70,-230,270,-190>
$output false
class Application : Core::Root
{
  $rect <30,340,210,380>
  inherited method Init()
  {
    var Core::Group newDialog = new Application::WelcomeScreen;
    PresentDialog( newDialog, null, null, null, null, null, null, null, null, false );
  }

  $rect <270,10,470,50>
  inherited property Bounds = <0,0,240,320>;

  // To do:
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widgets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <470,410,1250,610>;
  }
}

// This is a font resource.
$rect <550,-200,750,-160>
$output false
resource Resources::Font Font
{
  attr fontname FontName = Arial;
  attr fontheight Height = 32;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

$rect <550,-240,750,-200>
$output false
resource Resources::Font TitelFont
{
  attr fontname FontName = Arial;
  attr fontheight Height = 32;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <290,-230,490,-190>
$output false
class WelcomeScreen : Core::Group
{
  $rect <250,0,450,40>
  inherited property Bounds = <0,0,240,320>;

  $rect <250,90,450,130>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <250,50,450,90>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <460,280,1240,600>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <29,69,211,252>;
    preset AutoSize = false;
    preset Endless = true;
    preset Bitmap = Application::ZhawLogo;
    preset Embedded = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <240,0>;
    preset Point2 = <240,320>;
    preset Point1 = <0,320>;
    preset OnRelease = UpdateViewMenu;
  }

  $rect <250,160,450,200>
  slot UpdateViewMenu
  {
    var Core::Group newDialog = new Application::Menu;
    if (IsCurrentDialog())
      SwitchToDialog( newDialog, null, null, null, null, null, null, null, null, null, false );
  }
}

// Views
note group Views
{
  attr Bounds = <50,-280,510,750>;
}

// Resources
note group Resources
{
  attr Bounds = <530,-280,770,260>;
}

$rect <290,-190,490,-150>
$output false
class DetectorScreen : Core::Group
{
  $rect <554,161,734,201>
  inherited method Init()
  {
    if(Device.MainsDetected){
      ShowIcon.Enabled = true;
      ShowText.Enabled = true;
      ShowIcon.StartEffect;
      ShowText.StartEffect;
    } else {
      Image.Visible = false;
      WarningMessage.Visible = false;
      ShowIcon.StopEffect;
      ShowText.StopEffect;
      ShowIcon.Enabled = false;
      ShowText.Enabled = false;
    }
  }

  $rect <260,0,460,40>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,100,460,140>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,60,460,100>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <56,62,184,211>;
    preset Animated = false;
    preset Bitmap = Application::WarnSign;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text WarningMessage
  {
    preset Bounds = <0,168,240,254>;
    preset WrapText = false;
    preset String = "MAINS CABLE\nDETECTED!";
    preset Font = Application::Font;
    preset Color = #000000FF;
    preset Visible = true;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <0,0,240,86>;
    preset String = "Detector";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset Icon = Application::HomeIcon;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,160,460,200>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <550,60,750,100>
  object Effects::BoolEffect ShowIcon
  {
    preset Outlet = ^Image.Visible;
    preset CycleDuration = 1000;
    preset InterCycleDelay = 500;
    preset InitialDelay = 0;
    preset Enabled = true;
  }

  $rect <550,100,750,140>
  object Effects::BoolEffect ShowText
  {
    preset Outlet = ^WarningMessage.Visible;
    preset NoOfCycles = 1;
    preset InterCycleDelay = 500;
    preset Enabled = true;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <550,0,750,40>
  var Application::DeviceClass Device = Application::Device;

  $rect <260,240,460,280>
  object Core::PropertyObserver PropertyObserver
  {
    preset OnEvent = onEvent;
    preset Outlet = ^Application::Device.MainsDetected;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <460,240,660,280>
  slot onEvent
  {
    if(Device.MainsDetected){
      ShowIcon.Enabled = true;
      ShowText.Enabled = true;
      ShowIcon.StartEffect;
      ShowText.StartEffect;
    } else {
      Image.Visible = false;
      WarningMessage.Visible = false;
      ShowIcon.StopEffect;
      ShowText.StopEffect;
      ShowIcon.Enabled = false;
      ShowText.Enabled = false;
    }
  }

  // The object 'PropertyObserver' is a handler of property notifications. When the \
  // affected property is notified, the observer calls the associated slot method \
  // 'onEvent' automatically. Within the 'onEvent' method you can react to the notification. \
  // The method 'onEvent' exists for your convenience only. You can remove it and \
  // connect the observer with another slot method. See inline documentation inside \
  // the method.
  // 
  // Don't forget to connect the observer with the property of interest. To do this \
  // set the property 'Outlet' of the observer to refer to the desired property.
  note legend Note
  {
    attr Bounds = <670,240,1170,440>;
  }
}

$rect <290,-150,490,-110>
$output false
class CurrentMeasurement : Core::Group
{
  $rect <250,0,450,40>
  inherited property Bounds = <0,0,240,320>;

  $rect <250,160,450,200>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <250,120,450,160>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,80>;
    preset String = "Current\nMeasurement";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::Gauge Gauge
  {
    preset Bounds = <0,80,240,261>;
    preset Enabled = true;
    preset Outlet = ^Application::Device.Current;
    preset MaxValue = 5;
    preset CurrentValue = 3;
    preset Appearance = Application::BlueGauge;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[];
    preset Bounds = <82,160,159,192>;
    preset Outlet = ^Application::Device.Current;
    preset Unit = "A";
    preset Precision = 1;
    preset NoOfDigits = 0;
    preset CurrentBias = 0;
    preset CurrentFactor = 0.001;
    preset CurrentValue = 1578;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset Icon = Application::HomeIcon;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <250,220,450,260>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }
}

$rect <290,-70,490,-30>
$output false
class Utilities : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,51>;
    preset String = "Utilities";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <260,200,460,240>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset Icon = Application::HomeIcon;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,135,195,185>;
    preset OnRelease = UpdateViewCalibration;
    preset Label = "Calibration";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <45,194,195,244>;
    preset OnRelease = UpdateViewDebug;
    preset Label = "Debug";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <510,120,710,160>
  slot UpdateViewCalibration
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::Calibration, null, null, null, null, null, null, null, null, false );
  }

  $rect <510,160,710,200>
  slot UpdateViewDebug
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::Debug, null, null, null, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <45,77,195,127>;
    preset OnRelease = UpdateViewSettings;
    preset Label = "Settings";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <510,80,710,120>
  slot UpdateViewSettings
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::Settings, null, null, null, null, null, null, null, null, false );
  }
}

$rect <290,-110,490,-70>
$output false
class DistanceMeasurement : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,130,460,170>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,90,460,130>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,81>;
    preset String = "Distance\nMeasurement";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset Icon = Application::HomeIcon;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar
  {
    preset Bounds = <25,96,225,146>;
    preset Outlet = ^Application::Device.Distance;
    preset MaxValue = 200;
    preset CurrentValue = 50;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalValueBar HorizontalValueBar1
  {
    preset Bounds = <25,176,225,226>;
    preset Outlet = ^Application::Device.Angle;
    preset MaxValue = 90;
    preset CurrentValue = 45;
    preset Appearance = WidgetSet::HorizontalValueBar_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Bounds = <0,144,194,176>;
    preset Outlet = ^Application::Device.Distance;
    preset Unit = "mm";
    preset Precision = 0;
    preset CurrentValue = 50;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,226,153,258>;
    preset Outlet = ^Application::Device.Angle;
    preset Unit = "°";
    preset Precision = 0;
    preset CurrentValue = 45;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <260,200,460,240>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay2
  {
    preset Bounds = <125,279,223,311>;
    preset Outlet = ^Application::Device.StandartDeviation;
    preset Unit = "mm";
    preset Precision = 0;
    preset CurrentValue = 100;
    preset Appearance = WidgetSet::ValueDisplay_Small;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <71,279,136,311>;
    preset String = "Std. Dev.";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <550,-120,750,-80>
$output false
resource Resources::Bitmap ZhawLogo
{
  attr bitmapfile FileName = .\pictures\ZHAW_Logo.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Appearance
note group Buttons
{
  attr Bounds = <800,-280,1170,-80>;
}

$rect <550,-160,750,-120>
$output false
resource Resources::Font MenuButtonFont
{
  attr fontname FontName = Arial;
  attr fontheight Height = 22;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <550,-80,750,-40>
$output false
resource Resources::Bitmap WarnSign
{
  attr bitmapfile FileName = .\pictures\industrial-security-1492062.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <290,-30,490,10>
$output false
class Menu : Core::Group
{
  $rect <320,10,520,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <320,110,520,150>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <320,70,520,110>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <480,300,1260,620>;
  }

  $rect <550,10,750,50>
  slot UpdateViewDetector
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::DetectorScreen, null, null, null, null, null, null, null, null, false );
  }

  $rect <550,50,750,90>
  slot UpdateViewDistance
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::DistanceMeasurement, null, null, null, null, null, null, null, null, false );
  }

  $rect <550,90,750,130>
  slot UpdateViewCurrent
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::CurrentMeasurement, null, null, null, null, null, null, null, null, false );
  }

  $rect <550,130,750,170>
  slot UpdateViewUtilities
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::Utilities, null, null, null, null, null, null, null, null, false );
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,51>;
    preset String = "Menu";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton CurrentButton
  {
    preset Bounds = <0,225,120,320>;
    preset OnRelease = UpdateViewCurrent;
    preset Label = "Current";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton DistanceButton
  {
    preset Bounds = <120,130,240,225>;
    preset OnRelease = UpdateViewDistance;
    preset Label = "Distance";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton DetectorButton
  {
    preset Bounds = <0,130,120,225>;
    preset OnRelease = UpdateViewDetector;
    preset Label = "Detector";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SettingsButton
  {
    preset Bounds = <120,225,240,320>;
    preset OnRelease = UpdateViewUtilities;
    preset Label = "Utilities";
    preset Appearance = WidgetSet::PushButton_Medium;
  }
}

$rect <830,150,1030,190>
inline Inline
{
  /*

    TO DO:

    Include external header files or add type and function declarations needed
    in the implementation of Application::DeviceClass. For example:

      #include "DeviceDriver.h"

      #include "your_middleware_api.h"

      void Your_Middleware_Some_Function( int aSomeArg );

  */

  #include "DeviceDriver.h"
}

$rect <830,110,1030,150>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <30,80,230,120>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Application::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <30,40,230,80>
  inherited method Init()
  {
    // The following section is intended to perform initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. register the object by the middleware as receiver of events, etc.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           initialization steps. For example, you invoke some 'C' function:

             YourDevice_Initialize();

           The variable 'thisObject' represents the actually initialized instance of the
           Application::DeviceClass. You can store this variable e.g. in the middleware
           and use it whenever the middleware needs to notify the GUI application about
           some state alternation or events. In this manner, the middleware will be able
           to invoke methods of the interface device object.

           For example, you can store 'thisObject' in some global C variable:

             // Declaration of the global C variable
             XObject theDeviceObject;

             // Store the instance in the global variable
             theDeviceObject = thisObject;

           Later use the global variable e.g. to provide the GUI application with events:

             ApplicationDeviceClass__TriggerSomeEvent( theDeviceObject );

           IMPORTANT:
           ----------

           If you store 'thisObject' for later use, don't forget to implement the opposite
           operation in the method 'Done'. Concrete, 'Done' should set the global variable
           again to the value NULL.

        */
      }
    $endif
  }

  // The method 'Init' is executed just in the moment when new instance of 'Application::DeviceClass' \
  // is created. It is suitable to:
  // - initialize the hardware represented by the interface.
  // - register the instance by the middleware to receive updates and events.
  // - open files, network connections or other system resources needed by the interface.
  // 
  // The method 'Done' is executed just in the moment when an instance of 'Application::DeviceClass' \
  // is disposed. It is suitable to:
  // - de-initialize the underlying hardware.
  // - de-register the instance from the underlying middleware.
  // - close files, network connections and other no longer needed system resources.
  // 
  // If your application case doesn't need the initialization or de-initialization, \
  // feel free to delete the methods 'Init' or/and 'Done'.
  note legend Note3
  {
    attr Bounds = <320,0,1100,220>;
  }

  note arrow Note2
  {
    attr Point1 = <250,50>;
    attr Point2 = <320,50>;
  }

  // Constructor and Destructor
  note group Note1
  {
    attr Bounds = <10,0,250,140>;
  }

  $rect <40,280,240,320>
  property bool Lamptest;

  $rect <40,320,240,360>
  onset Lamptest
  {
    // The value doesn't change - nothing to do.
    if ( pure Lamptest == value )
      return;

    // Remember the property's new value.
    pure Lamptest = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    $if !$prototyper
      native ( value )
      {
        DeviceDriver_SetLampTest(value);
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Lamptest;
  }

  $rect <270,280,470,320>
  property int32 Current = 0;

  $rect <500,280,700,320>
  property int32 Distance;

  $rect <730,280,930,320>
  property int32 Angle;

  $rect <270,320,470,360>
  $output true
  method void UpdateCurrent( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Current )
    {
      // Remember the new value in the internal memory of the property.
      pure Current = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Current;
    }
  }

  $rect <500,320,700,360>
  $output true
  method void UpdateDistance( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Distance )
    {
      // Remember the new value in the internal memory of the property.
      pure Distance = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Distance;
    }
  }

  $rect <730,320,930,360>
  $output true
  method void UpdateAngle( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Angle )
    {
      // Remember the new value in the internal memory of the property.
      pure Angle = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Angle;
    }
  }

  $rect <40,380,240,420>
  property int32 DebugHall1;

  $rect <40,420,240,460>
  $output true
  method void UpdateDebugHall1( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure DebugHall1 )
    {
      // Remember the new value in the internal memory of the property.
      pure DebugHall1 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^DebugHall1;
    }
  }

  $rect <270,380,470,420>
  property int32 DebugHall2;

  $rect <270,420,470,460>
  $output true
  method void UpdateDebugHall2( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure DebugHall2 )
    {
      // Remember the new value in the internal memory of the property.
      pure DebugHall2 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^DebugHall2;
    }
  }

  $rect <500,380,700,420>
  property int32 DebugPad1;

  $rect <500,420,700,460>
  $output true
  method void UpdateDebugPad1( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure DebugPad1 )
    {
      // Remember the new value in the internal memory of the property.
      pure DebugPad1 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^DebugPad1;
    }
  }

  $rect <730,380,930,420>
  property int32 DebugPad2;

  $rect <730,420,930,460>
  $output true
  method void UpdateDebugPad2( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure DebugPad2 )
    {
      // Remember the new value in the internal memory of the property.
      pure DebugPad2 = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^DebugPad2;
    }
  }

  $rect <970,280,1170,320>
  property bool MainsDetected = 0;

  $rect <970,320,1170,360>
  $output true
  method void UpdateMainsDetected( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure MainsDetected )
    {
      // Remember the new value in the internal memory of the property.
      pure MainsDetected = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^MainsDetected;
    }
  }

  $rect <970,380,1170,420>
  property bool Precision;

  $rect <970,420,1170,460>
  $output true
  onset Precision
  {
    // The value doesn't change - nothing to do.
    if ( pure Precision == value )
      return;

    // Remember the property's new value.
    pure Precision = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    $if !$prototyper
      native ( value )
      {
        if(value){
          DeviceDriver_SetPrecision(true);
        } else {
          DeviceDriver_SetPrecision(false);
        }
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Precision;
  }

  $rect <40,480,240,520>
  property int32 SelectWire = 1;

  $rect <40,520,240,560>
  onset SelectWire
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectWire == value )
      return;

    // Remember the property's new value.
    pure SelectWire = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    $if !$prototyper
      native ( value )
      {
        DeviceDriver_SetWireSelection(value);
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^SelectWire;
  }

  $rect <270,480,470,520>
  property int32 StandartDeviation;

  $rect <270,520,470,560>
  $output true
  method void UpdateStandartDeviation( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure StandartDeviation )
    {
      // Remember the new value in the internal memory of the property.
      pure StandartDeviation = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^StandartDeviation;
    }
  }

  $rect <500,480,700,520>
  property bool SelectedCalibration = 0;

  $rect <500,520,700,560>
  $output true
  onset SelectedCalibration
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedCalibration == value )
      return;

    // Remember the property's new value.
    pure SelectedCalibration = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
    $if !$prototyper
      native ( value )
      {
        if(value){
          DeviceDriver_SetPrecision(true);
        } else {
          DeviceDriver_SetPrecision(false);
        }
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^SelectedCalibration;
  }
}

$rect <1030,110,1230,150>
autoobject Application::DeviceClass Device;

// Device Interface
note group Note
{
  attr Bounds = <800,60,1260,260>;
}

// This autoobject provides the default customization for the 'analog gauge' widget \
// (WidgetSet::Gauge) in its medium size variant.
$rect <830,-230,1130,-190>
$output false
autoobject WidgetSet::GaugeConfig BlueGauge
{
  preset SwingElastic = false;
  preset SwingDuration = 300;
  preset TrackLeftRoundedStart = true;
  preset TrackLeftColor = #0064A6FF;
  preset TrackLeftThickness = 21.0;
  preset TrackLeftRadius = 70.0;
  preset NeedleMaxAngle = -45;
  preset NeedleMinAngle = 225;
  preset NeedlePivot = <-39,12>;
  preset Needle = Application::BlueNeedle;
  preset CenterOffset = <0,10>;
  preset Scale = WidgetSet::GaugeTrackMedium;
  preset WidgetMinSize = <171,151>;
}

// This autoobject provides the default customization for the 'push button' widget \
// (WidgetSet::PushButton) in its medium size variant.
$rect <830,-190,1130,-150>
$output false
autoobject WidgetSet::PushButtonConfig BluePushButton
{
  preset LabelColorActive = #FFFFFFFF;
  preset LabelColorFocused = #FFFFFFFF;
  preset LabelColorDisabled = #A8ABABFF;
  preset LabelColorDefault = #6C6E70FF;
  preset LabelMarginBottom = 6;
  preset LabelMarginTop = 6;
  preset LabelMarginRight = 6;
  preset LabelMarginLeft = 6;
  preset IconTintDisabled = #A8ABABAA;
  preset IconTintDefault = #6C6E70FF;
  preset IconMarginBottom = 6;
  preset IconMarginTop = 6;
  preset IconMarginRight = 6;
  preset IconMarginLeft = 6;
  preset LabelFont = Resources::FontMedium;
  preset FaceFrameActive = 3;
  preset FaceFrameFocused = 2;
  preset FaceFrameDisabled = 0;
  preset FaceFrameDefault = 1;
  preset FaceActive = Application::BlueNeedle;
  preset FaceFocused = Application::BlueNeedle;
  preset FaceDisabled = Application::BlueNeedle;
  preset FaceDefault = Application::BlueNeedle;
  preset WidgetMinSize = <34,34>;
}

$rect <550,-40,750,0>
$output false
resource Resources::Bitmap HomeIcon
{
  attr bitmapfile FileName = .\pictures\Home.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <550,0,750,40>
$output false
resource Resources::Bitmap BlueNeedle
{
  attr bitmapfile FileName = .\pictures\GaugeNeedleLarge_blue.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// This autoobject provides the default customization for the 'horizontal value bar' \
// widget (WidgetSet::HorizontalValueBar) in its medium size variant.
$rect <830,-150,1130,-110>
$output false
autoobject WidgetSet::HorizontalValueBarConfig BlueValueBar
{
  preset TrackRightFrame = 0;
  preset TrackRight = WidgetSet::HorizontalValueBarMedium;
  preset TrackLeftFrame = 1;
  preset TrackLeft = WidgetSet::HorizontalValueBarMedium;
  preset WidgetMinSize = <45,30>;
}

$rect <70,-30,270,10>
$output false
class Debug : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,51>;
    preset String = "Debug";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <260,200,460,240>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset IconFrame = 12;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Bounds = <20,74,220,106>;
    preset Outlet = ^Application::Device.DebugHall1;
    preset Unit = "Hall1";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay1
  {
    preset Bounds = <20,115,220,147>;
    preset Outlet = ^Application::Device.DebugHall2;
    preset Unit = "Hall2";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay2
  {
    preset Bounds = <20,160,220,192>;
    preset Outlet = ^Application::Device.DebugPad1;
    preset Unit = "Pad1";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay3
  {
    preset Bounds = <20,199,220,231>;
    preset Outlet = ^Application::Device.DebugPad2;
    preset Unit = "Pad2";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }
}

$rect <70,-70,270,-30>
$output false
class Calibration : Core::Group
{
  $rect <810,120,1010,160>
  inherited method Done()
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibration(false);
      }
    $endif
  }

  $rect <830,80,1010,120>
  inherited method Init()
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibration(true);
      }
    $endif
  }

  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,51>;
    preset String = "Calibration";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <260,200,460,240>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset IconFrame = 12;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,68,195,118>;
    preset OnRelease = OpenCalibrationDialog;
    preset Label = "Start";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <45,130,195,180>;
    preset Label = "Save";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <45,194,195,244>;
    preset Label = "Reset";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <510,80,710,120>
  slot OpenCalibrationDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().PresentDialog( new Application::SelectCalibration, Application::FadeInOutCentered, null, null, null, null, null, null, null, false );
  }
}

$rect <70,150,270,190>
$output false
class CalibrationWindow1 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Distance";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow2, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(0, 0);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "2 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <70,190,270,230>
$output false
class CalibrationWindow2 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Distance";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow3, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow1, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(0, 1);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "5 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <70,230,270,270>
$output false
class CalibrationWindow3 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Distance";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow4, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow2, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(0, 2);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <70,79,170,109>;
    preset String = "10 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,150,490,190>
$output false
class CalibrationWindow4 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Distance";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow5, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow3, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(0, 3);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "20 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,190,490,230>
$output false
class CalibrationWindow5 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Distance";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow6, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow4, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(0, 4);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "50 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,230,490,270>
$output false
class CalibrationWindow6 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Distance";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow7, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow5, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(0, 5);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "100 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,270,490,310>
$output false
class CalibrationWindow7 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 8;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Distance";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow6, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(0, 6);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <70,79,170,109>;
    preset String = "200 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <990,330,1240,370>
$output false
autoobject Effects::SlideTransition SlideRight
{
  preset Alignment = Effects::DialogAlignment[AlignHorzCenter, AlignVertCenter];
  preset Direction = Core::Direction.Right;
}

$rect <990,370,1240,410>
$output false
autoobject Effects::SlideTransition SlideLeft
{
  preset Direction = Core::Direction.Left;
}

$rect <990,410,1240,450>
$output false
autoobject Effects::FadeInOutTransition FadeInOutCentered;

$rect <70,-110,270,-70>
$output false
class Settings : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <470,290,1250,610>;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #DCDCDCFF;
  }

  // This is an ordinary text view.
  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,240,51>;
    preset String = "Settings";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <260,200,460,240>
  slot UpdateViewMenu
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, null, null, null, null, null, true );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MenuButton
  {
    preset Bounds = <0,270,50,320>;
    preset OnRelease = UpdateViewMenu;
    preset IconFrame = 12;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <25,64,215,114>;
    preset Outlet = ^Application::Device.Lamptest;
    preset Label = "Lamptest";
    preset Appearance = WidgetSet::Switch_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton1
  {
    preset Bounds = <25,110,215,160>;
    preset Outlet = ^Application::Device.Precision;
    preset Checked = false;
    preset Label = "Precision";
    preset Appearance = WidgetSet::Switch_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::HorizontalSlider HorizontalSlider
  {
    preset Bounds = <20,174,220,224>;
    preset Outlet = ^Application::Device.SelectWire;
    preset MaxValue = 2;
    preset CurrentValue = 1;
    preset Appearance = WidgetSet::HorizontalSlider_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <0,216,64,246>;
    preset String = "L";
    preset Font = Application::Font;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <176,216,240,246>;
    preset String = "L/N";
    preset Font = Application::Font;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <76,216,164,246>;
    preset String = "L/N/PE";
    preset Font = Application::Font;
    preset Color = #000000FF;
  }
}

// This is a font resource.
$rect <550,100,750,140>
$output false
resource Resources::Font CalibrationTextFont
{
  attr fontname FontName = Arial;
  attr fontheight Height = 22;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

$rect <70,70,270,110>
$output false
class SelectCalibration : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <49,227,199,277>;
    preset OnRelease = CalCur2Dialog;
    preset Label = "Current 2";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,37,210,101>;
    preset String = "Select\nCalibration";
    preset Font = Application::TitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,240,460,280>
  slot CalDisDialog
  {
    if (IsActiveDialog(true)){
      Device.SelectedCalibration = false;
      GetRoot().SwitchToDialog( new Application::CalibrationWindow1, null, null, null, null, null, null, null, null, null, false );
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <49,168,199,218>;
    preset OnRelease = CalCur1Dialog;
    preset Label = "Current 1";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,280,460,320>
  slot CalCur1Dialog
  {
    if (IsActiveDialog(true)){
      Device.SelectedCalibration = true;
      GetRoot().SwitchToDialog( new Application::CalibrationWindow8, null, null, null, null, null, null, null, null, null, false );
    }
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <49,110,199,160>;
    preset OnRelease = CalDisDialog;
    preset Label = "Distance";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,320,460,360>
  slot CalCur2Dialog
  {
    if (IsActiveDialog(true)){
      Device.SelectedCalibration = true;
      GetRoot().SwitchToDialog( new Application::CalibrationWindow15, null, null, null, null, null, null, null, null, null, false );
    }
  }
}

// Effects
note group EffectNote
{
  attr Bounds = <970,280,1260,480>;
}

// This is a font resource.
$rect <550,60,750,100>
$output false
resource Resources::Font CalibrationTitelFont
{
  attr fontname FontName = Arial;
  attr fontheight Height = 36;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = true;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontheightmode HeightMode = Compatible;
  attr fontrowdistance RowDistance;
}

$rect <70,350,270,390>
$output false
class CalibrationWindow8 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 1";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow9, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(1, 0);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "1 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <70,390,270,430>
$output false
class CalibrationWindow9 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 1";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow10, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow8, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(1, 1);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "2 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <70,430,270,470>
$output false
class CalibrationWindow10 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 1";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow11, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow9, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(1, 2);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <70,79,170,109>;
    preset String = "5 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,350,490,390>
$output false
class CalibrationWindow11 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 1";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow12, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow10, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(1, 3);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "7 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,390,490,430>
$output false
class CalibrationWindow12 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 1";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow13, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow11, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(1, 4);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "10 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,430,490,470>
$output false
class CalibrationWindow13 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 1";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow14, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow12, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(1, 5);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "15 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,470,490,510>
$output false
class CalibrationWindow14 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 8;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 1";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow13, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(1, 6);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <70,79,170,109>;
    preset String = "20 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <70,550,270,590>
$output false
class CalibrationWindow15 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 2";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow16, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(2, 0);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "1 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <70,590,270,630>
$output false
class CalibrationWindow16 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 2";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow17, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow15, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(2, 1);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "2 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <70,630,270,670>
$output false
class CalibrationWindow17 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 2";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow18, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow16, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(2, 2);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <70,79,170,109>;
    preset String = "5 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,550,490,590>
$output false
class CalibrationWindow18 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 2";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow19, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow17, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(2
        , 3);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "7 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,590,490,630>
$output false
class CalibrationWindow19 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 2";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow20, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow18, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(2, 4);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "10 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,630,490,670>
$output false
class CalibrationWindow20 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = NextDialog;
    preset IconFrame = 3;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 2";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,240,460,280>
  slot NextDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow21, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow19, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(2, 5);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <30,79,210,109>;
    preset String = "15 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}

$rect <290,670,490,710>
$output false
class CalibrationWindow21 : Core::Group
{
  $rect <260,10,460,50>
  inherited property Bounds = <0,0,240,320>;

  $rect <260,120,460,160>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <260,80,460,120>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,240,320>;
    preset Color = #00000099;
  }

  // This is a filled rectangle view.
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <30,30,210,290>;
    preset Color = #DCDCDCFF;
  }

  // Variable to reference the device class the entire lifetime of the application. \
  // This avoids that the device class will be deleted by the Garbage Collector.
  $rect <510,10,710,50>
  var Application::DeviceClass Device = Application::Device;

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous
  {
    preset Bounds = <30,240,80,290>;
    preset OnRelease = PreviosDialog;
    preset IconFrame = 2;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Next
  {
    preset Bounds = <160,240,210,290>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 8;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <45,172,195,222>;
    preset OnRelease = SetValue;
    preset Label = "Load";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ValueDisplay ValueDisplay
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <30,116,210,148>;
    preset Unit = "";
    preset Precision = 0;
    preset Appearance = WidgetSet::ValueDisplay_Medium;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <30,49,210,79>;
    preset String = "Current 2";
    preset Font = Application::CalibrationTitelFont;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Previous1
  {
    preset Bounds = <185,5,235,55>;
    preset OnRelease = ExitDialog;
    preset IconFrame = 9;
    preset Icon = Resources::NavigationIconsMedium;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <260,200,460,240>
  slot ExitDialog
  {
    if ( IsActiveDialog( true ))
      Owner.DismissDialog( this, Application::FadeInOutCentered, null, null, null, null, true );
  }

  $rect <260,280,460,320>
  slot PreviosDialog
  {
    if (IsActiveDialog(true)) 
      GetRoot().SwitchToDialog( new Application::CalibrationWindow20, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <260,320,460,360>
  slot SetValue
  {
    $if !$prototyper
      native
      {
        DeviceDriver_SetCalibrationValue(2, 6);
      }
    $endif
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <70,79,170,109>;
    preset String = "20 mm";
    preset Font = Application::CalibrationTextFont;
    preset Color = #000000FF;
  }
}
